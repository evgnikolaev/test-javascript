/*
	Регулярные выражения
	Работа со сторками.( по сути ctrl+F (найти заменить во всем тексте)) Либо испоьлзовать как трафаретки.

	Регулярные выражения - отдельный тип, класс.
	1 способ:  var pattern = /as/; - без ковычек
	2 способ:  new RegExp(/fff/);

	/ регулярка /флаг
	i - регистроНЕзависимый
	g - глобальный  - абсолютно ВСЕ вхождения
	m - многострочный (редко)


	МЕТОДЫ
	метод строки
	string.search( строка или регулярка ) - возвращает только первую позицию
	string.match( регулярка ) - учитывает флаг g (возвращает индексированный массив с буквами),
								без флага g (возвращает букву, позицию, строку)
	string.split( строка или регулярка ) - строку в массив
	string.replace( строка или регулярка) - замени

	метод регулярки
	reg.test( строка ) - true/false если хотя бы одно совпадение было найдено
	reg.exec( строка ) - метод поиска, немного похож на match и search


	РЕГУЛЯРКИ
	/^abc$/	-	^ $ начало и конец СТРОКИ
	| - логическое или
	. - любой символ, кроме переноса строки

	классы
	\d  -	любой номер 0-9
	\D	-	не число
	\w	-	любая латинска буква, цифра, знак подчеркивания [A-Za-z0-9_] . С кириллицей не работает.
	\W	-	не [A-Za-z0-9_]
	\s	-	пробел (табуляция, перенос строки)
	\S	-	не пробел
	\b	-	граница слова. (проверка более корректная чем проверка на пробелы, например может быть запятая, точка ...)
	\B	-	не граница слова (в середине слова)
	\^	-	экранируем спецсивол     / . + ? [] () {} \ - *

	[abc] - класс набор(любой символ из перечисленных), либо a, либо b, либо c
	[а-я] - от а до я ( дефиз здесь спецсивол, внутри квадратных скобок. Квадратные скобки это спецсимвол)
	[^abc] - класс набор(любой символ КРОМЕ перечисленных), кроме a, или кроме b, или кроме c

	квантификаторы (количество чего либо)
	+	-	 один и более (\d+)
	?	-	ноль или один (\w?)
	*	-	ноль и более (\s*)
	{3}	-	жестко ( \w{3} - 3 любых символа  )
	{3,}	-	3 и более
	{3,6}	-	от 3 до 6

	Повторения бывают
	Жадные	-	по умолчанию. Токен будет повторяться на столько много раз насколько это возможно(будет браться максимальный шаблон)
	Не жадный -  после повторения ставим вопросительный знак {3,6}? или +?

	Вперед смотрящее утверждение
		например хотим найти только те слова and после которых есть пробел и he
		and(?=\she) - вернется and

	Вперед смотрящее отрицание
		\bto\b(?!\sknow) - все слова to, после которых нет слова know , вернет to
		В других языках есть назад смотрящее утверждение, отрицание. Но в js такого нет.



	группировка
	(go){2,}	- go 2 и более раз
	java(?:script)? - при такой ?: записи не будет создаваться запоминающей группы

*/
var pattern = /as/;
new RegExp(/fff/);


var string = 'hellO world';
// console.log(string.indexOf('o'));// вернет 7

// console.log(string.search('o'));// вернет 7
// console.log(string.search(/o/i));// вернет 4
// console.log(string.match(/o/));
// console.log(string.match(/o/ig));

var repl = '12-03-89';
// console.log(repl.replace('-', ':'));//строка, заменит первый
// console.log(repl.replace(/-/g, ':'));//регулярка с флагом g, заменит все

var reg = /ad/;
// console.log(reg.test('adf'));
// console.log(reg.exec('adf'));

// console.log('hello world,sdf'.match(/\bworld\b/));//пример с границей слова


var tel = '+00 (000) 000 00 00 ';
// console.log(tel.match(/\+\d{1,2} \(\d{3}\) \d{3} \d{2}/));

var str = 'gogogassdfgogo';
console.log(str.match(/(go){2,}/));


//жадность
var str2 = 'month maybe. He just';
// console.log(str2.match(/a.{2,6}?e/g)); //вернет 'aybe. H'. По умолчанию жадный, максимальный.


/*
 *	Пример1
 */
function Inp() {
	var but = document.getElementById('but');
	var inp = document.getElementById('inp');

	this.checkEmail = function () {
		var pattern = /^\w+@\w{2,}\.\w{2,}$/;
		console.log(pattern.test(inp.value));
	};
	but.addEventListener('click', this.checkEmail);
}

var pr = new Inp();

